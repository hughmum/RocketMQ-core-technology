⚡ 项目简介 ⚡

### 技术栈
- JDK 8  
- zookeeper 3.4.9
- dubbo 
- rocketmq 4.4.0 

# RocketMQ-core-technology
## 双11抗压场景分析
- 电商平台 ,加入购物车 -> 用户下单 -> 有用户支付

### 购物车
#### 加入购物车（缓存）
- 维度设计 
#### 添加商品操作
- 通过地址划分，通过用户id划分，通过不同的规则将数据路由到不同的缓存中
- 根据路由key进行路由到不同的redis集群
#### redis集群
一般设置为 一主两从
#### redis 同步
- mysql binlog rdb aof
### 用户下单
#### 用户下单请求
- 更具业务维度请求不同的set化服务器进行处理
#### 高并发问题
- 限流、降级、兜底
#### 库存订单一致性问题
- 库存订单同库处理
- 不同库，接口做幂等性处理，接口调用 `最终一致`
### 用户支付
- 明白业务边界
- 微服务同步调用强一致性、最终一致性（补偿）
- MQ拆分，高可靠投递、最终一致性问题处理（分布式事务消息）
## 解决方案
### 前端dns 解析 、负载均衡分流、限流
nginx流量分发、redis 限流.....
### 缓存的业务拆分
### 微服务流控（guava ratelimiter 、semaphore、hystrix）
### 降级熔断、兜底、动态调整阈值、降级兜底策略 
### 微服务幂等性
- redis 分布式锁去重消息id
- 去重表
### 分库分表策略

###  冷热数据 / 读取分离
- mysql 读写分离 
- es hive （冷数据）
### 有效业务数据过滤、业务解耦、微服务拆分
### 顺序消息、局部顺序并行化处理消息
### 分布式事务

## 限流策略
- 控制总并发数
- 平滑控制并发数
  在短时间内允许多少请求通过
- 时间窗口控制并发数
  在一个时间段允许多少请求通过，这可能导致短时间内通过大量请求而时间段中的其他时间不能通过请求
## 限流算法
### 漏桶算法（平滑处理请求）
### 令牌桶算法（时间窗口限流法）
在一个时间窗口内只颁发固定数量的令牌，没拿到令牌的请求拒绝

## 支付业务三步骤
1. 接口入口token去重，防止重复提交
2. 账号多线程环境下金额在一个时刻只能被一个线程操作，使用分布式锁实现
3. 数据库层面使用乐观锁机制更新金额，防止金额变为负数
## 顺序消费
- 全局
- 局部
> 将同业务Id相同的消息发送到同一queue. producer和consumer 配合处理（局部有序）
> 

#项目说明
项目来源于 https://coding.imooc.com/class/292.html
教程包含了rocketmq的一些原理、事务消息、顺序消息、以及电商平台的落地方案
rocketmq 是4.4.0版本需要注意的是客户端和服务端版本务必要一致
zk使用的是3.4.9
项目我在原有的基础上改了一些包名以及部分代码写法不同